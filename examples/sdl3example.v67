import sdl3 as sdl

// Define SDL_Event structure for direct field access
// NOTE: This only declares the common header fields.
// The actual SDL_Event is a union that is 128 bytes on Linux x86_64.
cstruct SDL_Event {
    type as uint32,
    timestamp as uint64
}

// Set the window dimentions
width = 620
height = 387

// Initialize SDL with SDL_Init. Use the "or!" keyword to handle the case where SDL_Init returns nothing.
sdl.SDL_Init(sdl.SDL_INIT_VIDEO) or! {
    // Exitf is like printf, but writes to stderr and also quits the program with error code 1
    exitf("SDL_Init failed: %s\n", sdl.SDL_GetError()!)
}

// Call SDL_Quit when the program ends
defer sdl.SDL_Quit()

// Create window, or exit with an error
window = sdl.SDL_CreateWindow("Hello World!", width, height, 0)! or! {
    println("SDL_CreateWindow returned NULL!")
    printf("SDL Error: %s\n", sdl.SDL_GetError()!)
    exitf("Failed to create window\n")
}

printf("Window pointer: %p\n", window as cptr)

// Call SDL_DestroyWindow when the program ends (before SDL_Quit)
defer sdl.SDL_DestroyWindow(window)

// Create renderer, or exit with an error
renderer = sdl.SDL_CreateRenderer(window, 0)! or! {
    exitf("Failed to create renderer: %s\n", sdl.SDL_GetError()!)
}

// Call SDL_DestroyRenderer when the program ends (before SDL_DestroyWindow and SDL_Quit)
defer sdl.SDL_DestroyRenderer(renderer)

// Load BMP file, or exit with an error
file = sdl.SDL_IOFromFile("img/grumpy-cat.bmp", "rb")! or! {
    exitf("Error reading file: %s\n", sdl.SDL_GetError()!)
}

// Load surface from file, or exit with an error
bmp = sdl.SDL_LoadBMP_IO(file, 1)! or! {
    exitf("Error creating surface: %s\n", sdl.SDL_GetError()!)
}

// Clean up the surface when the program ends
defer sdl.SDL_DestroySurface(bmp)

// Create texture from surface, or exit with an error
tex = sdl.SDL_CreateTextureFromSurface(renderer as cptr, bmp as cptr)! or! {
    exitf("Error creating texture: %s\n", sdl.SDL_GetError()!)
}

// Clean up the surface when the program ends
defer sdl.SDL_DestroyTexture(tex)

// Main loop - display until window closed or ESC pressed
running := 1

// Allocate event buffer with actual SDL_Event size (128 bytes on Linux x86_64)
// Use ! to get raw pointer bits (preserves all 64 bits)
// Cast to our partial cstruct type for field access to common header
// NOTE: sizeof(SDL_Event) returns our partial cstruct size (16), not the real size (128)
event := (c.malloc(128) as SDL_Event)
null_ptr := 0

@ running > 0 max inf {
    // Poll all pending events
    @ sdl.SDL_PollEvent(event) > 0 max inf {
        // Direct field access now works thanks to type casting!
        event.type {
            256 => {
                // SDL_EVENT_QUIT (0x100) - window close button
                running <- 0
            }
            768 => {
                // SDL_EVENT_KEY_DOWN (0x300)
                // Read scancode from offset 16 (inside SDL_KeyboardEvent)
                scancode := peek32(event, 16)
                scancode {
                    41 => {
                        // SDL_SCANCODE_ESCAPE = 41
                        running <- 0
                    }
                    20 => {
                        // SDL_SCANCODE_Q = 20
                        running <- 0
                    }
                }
            }
        }
    }

    // Clear screen
    sdl.SDL_RenderClear(renderer)

    // Render texture (fills entire window)
    sdl.SDL_RenderTexture(renderer, tex, null_ptr, null_ptr)

    // Present the rendered frame
    sdl.SDL_RenderPresent(renderer)

    // Delay to maintain framerate
    sdl.SDL_Delay(16)  // ~60 FPS
}

c.free(event)

// That's it - all resources cleaned up by defer statements
